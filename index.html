<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Irregular Shape Area Calculator</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<style>
body{
  font-family:Arial;
  background:#f0f0f0;
  display:flex;
  flex-direction:column;
  align-items:center;
  margin:0;
}
h1{
  background:#4CAF50;
  color:#fff;
  width:100%;
  text-align:center;
  margin:0;
  padding:10px;
  font-size:22px;
}
.controls{
  margin:20px;
  display:flex;
  flex-wrap:wrap;
  gap:10px;
  justify-content:center;
}
.controls button,.controls select{
  padding:10px 15px;
  background:#4CAF50;
  color:white;
  border:none;
  border-radius:5px;
  cursor:pointer;
}
canvas{
  border:2px solid #333;
  background:#fff;
}
.output{
  background:#fff;
  padding:10px 20px;
  border-radius:5px;
  margin:10px;
  white-space:pre-line;
}
</style>
</head>

<body>

<h1>Irregular Shape Area Calculator</h1>

<div class="controls">
<select id="unitSelect">
<option value="m">Meters</option>
<option value="cm">Centimeters</option>
<option value="ft">Feet</option>
<option value="in">Inches</option>
<option value="metricLink">Metric Link</option>
<option value="gunterLink">Gunter Link</option>
</select>

<button id="diagonalBtn" onclick="toggleDiagonal()">Add Diagonal</button>
<button onclick="calculateAndAdjust()">Calculate Area</button>
<button onclick="undo()">Undo</button>
<button onclick="redo()">Redo</button>
<button onclick="reset()">Reset</button>
<button onclick="exportPDF()">Export PDF</button>
</div>

<canvas id="canvas"></canvas>
<div id="output" class="output">Total Area: 0.00 m²</div>

<script>
const { jsPDF } = window.jspdf;
const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");

let points=[],edges=[],diagonals=[],lengths={};
let shapeClosed=false,addingDiagonal=false,tempDiagStart=null;
let undoStack=[],redoStack=[];
let canvasLocked=false;

/* ✅ NEW — MOBILE SNAP RADIUS */
function getSnapRadius(){
 return window.innerWidth < 700 ? 20 : 10;
}

/* ---------- CANVAS ---------- */
function resizeCanvas(force=false){
 if(canvasLocked && !force) return;
 const size=Math.min(window.innerWidth,window.innerHeight)-60;
 const r=window.devicePixelRatio||1;
 canvas.width=size*r;
 canvas.height=size*r;
 canvas.style.width=size+"px";
 canvas.style.height=size+"px";
 ctx.setTransform(r,0,0,r,0,0);
 ctx.font="12px Arial";
}
resizeCanvas(true);
window.addEventListener("resize",()=>resizeCanvas());

/* ---------- INPUT ---------- */
canvas.addEventListener("click",(e)=>{
 const rect=canvas.getBoundingClientRect();
 let x=Math.round((e.clientX-rect.left)/10)*10;
 let y=Math.round((e.clientY-rect.top)/10)*10;

 if(!canvasLocked && points.length===0) canvasLocked=true;

 if(!shapeClosed && !addingDiagonal){
  saveState();
  const snap=points.findIndex(p=>Math.hypot(p[0]-x,p[1]-y)<getSnapRadius());
  if(snap===0 && points.length>=3){
   shapeClosed=true;
   edges.push([points.length-1,0]);
  } else {
   points.push([x,y]);
   if(points.length>1) edges.push([points.length-2,points.length-1]);
  }
 }
 else if(addingDiagonal && shapeClosed){
  const idx=points.findIndex(p=>Math.hypot(p[0]-x,p[1]-y)<getSnapRadius());
  if(idx!==-1){
   if(tempDiagStart===null) tempDiagStart=idx;
   else if(tempDiagStart!==idx){
    saveState();
    diagonals.push([tempDiagStart,idx]);
    tempDiagStart=null;
   }
  }
 }
 else if(shapeClosed){
  const line=getLineUnderCursor(x,y);
  if(line){
   const key=line.slice().sort().join("-");
   const val=prompt("Enter line length:",lengths[key]||"");
   if(!isNaN(parseFloat(val))){
    saveState();
    lengths[key]=parseFloat(val);
   }
  }
 }
 draw();
});

/* ---------- TOGGLE ---------- */
function toggleDiagonal(){
 addingDiagonal=!addingDiagonal;
 tempDiagStart=null;
 document.getElementById("diagonalBtn").style.background=
 addingDiagonal?"#ff5722":"#4CAF50";
}

/* ---------- HELPERS ---------- */
function getLineUnderCursor(x,y){
 for(const [a,b] of [...edges,...diagonals]){
  const [x1,y1]=points[a];
  const [x2,y2]=points[b];
  if(distanceToSegment(x,y,x1,y1,x2,y2)<getSnapRadius()) return [a,b];
 }
 return null;
}
function distanceToSegment(px,py,x1,y1,x2,y2){
 const l2=(x2-x1)**2+(y2-y1)**2;
 if(!l2) return Math.hypot(px-x1,py-y1);
 let t=((px-x1)*(x2-x1)+(py-y1)*(y2-y1))/l2;
 t=Math.max(0,Math.min(1,t));
 return Math.hypot(px-(x1+t*(x2-x1)),py-(y1+t*(y2-y1)));
}
function triangleArea(a,b,c){
 const s=(a+b+c)/2;
 return Math.sqrt(s*(s-a)*(s-b)*(s-c));
}
function isTriangleValid(a,b,c){
 return a+b>c && a+c>b && b+c>a;
}

/* ---------- CALCULATE + AUTO FIT ---------- */
function calculateAndAdjust(){
 if(!shapeClosed) return alert("First close shape.");
 resizeCanvas(true);

 const known=Object.entries(lengths)
 .map(([k,v])=>({k,v:parseFloat(v)}))
 .filter(o=>!isNaN(o.v));

 if(known.length){
 const size = canvas.width/(window.devicePixelRatio||1);
 const usable = size*0.6;
 const maxLen = Math.max(...known.map(o=>o.v));
 const scaleFactor = usable/maxLen;

 const scaledKnown = known.map(o=>({k:o.k,v:o.v*scaleFactor}));

 for(let iter=0;iter<300;iter++){
  scaledKnown.forEach(({k,v})=>{
   const [i,j]=k.split("-").map(Number);
   let dx=points[j][0]-points[i][0];
   let dy=points[j][1]-points[i][1];
   let d=Math.hypot(dx,dy)||0.0001;
   let diff=(d-v)/d*0.5;

   points[i][0]+=dx*diff;
   points[i][1]+=dy*diff;
   points[j][0]-=dx*diff;
   points[j][1]-=dy*diff;
  });
 }
 }

 const size = canvas.width/(window.devicePixelRatio||1);
 const pad=20;

 let xs=points.map(p=>p[0]);
 let ys=points.map(p=>p[1]);

 let minX=Math.min(...xs);
 let maxX=Math.max(...xs);
 let minY=Math.min(...ys);
 let maxY=Math.max(...ys);

 let w=maxX-minX || 1;
 let h=maxY-minY || 1;

 let fitScale=Math.min(
  (size-2*pad)/w,
  (size-2*pad)/h,
  1
 );

 let cx=(minX+maxX)/2;
 let cy=(minY+maxY)/2;

 points=points.map(([x,y])=>[
  (x-cx)*fitScale + size/2,
  (y-cy)*fitScale + size/2
 ]);

 let total=0;
 const graph=Array.from({length:points.length},()=>[]);
 [...edges,...diagonals].forEach(([a,b])=>{
  graph[a].push(b); graph[b].push(a);
 });

 const tris=[];
 for(let i=0;i<points.length;i++)
  for(let j of graph[i])
   for(let k of graph[j])
    if(k!==i && graph[k].includes(i)){
     const t=[i,j,k].sort();
     if(!tris.some(x=>x.join()==t.join())) tris.push(t);
    }

 for(const [a,b,c] of tris){
  const ab=lengths[[a,b].sort().join("-")];
  const bc=lengths[[b,c].sort().join("-")];
  const ca=lengths[[c,a].sort().join("-")];
  if(ab&&bc&&ca) total+=triangleArea(ab,bc,ca);
 }

 const unit=document.getElementById("unitSelect").value;
 const toM={m:1,cm:0.01,ft:0.3048,in:0.0254,metricLink:0.2,gunterLink:0.2012};
 const f=toM[unit]||1;
 const m2=total*f*f;

 document.getElementById("output").innerText=
`Total Area:
${m2.toFixed(2)} m²
${(m2*10000).toFixed(2)} cm²
${(m2*10.7639).toFixed(2)} ft²
${(m2*1550.003).toFixed(2)} in²
${(m2/4046.8564).toFixed(4)} acres`;

 draw();
}

/* ---------- DRAW ---------- */
function draw(){
 ctx.clearRect(0,0,canvas.width,canvas.height);

 const drawLine=([a,b],c)=>{
  ctx.strokeStyle=c;
  ctx.beginPath();
  ctx.moveTo(...points[a]);
  ctx.lineTo(...points[b]);
  ctx.stroke();

  const midX=(points[a][0]+points[b][0])/2;
  const midY=(points[a][1]+points[b][1])/2;
  const key=[a,b].sort().join("-");
  const label=lengths[key]??key;

  ctx.fillStyle="#000";
  ctx.fillText(label,midX,midY);
 };

 edges.forEach(e=>drawLine(e,"black"));
 diagonals.forEach(d=>drawLine(d,"blue"));

 points.forEach(([x,y],i)=>{
  ctx.fillStyle="red";
  ctx.beginPath();
  ctx.arc(x,y,4,0,Math.PI*2);
  ctx.fill();
  ctx.fillStyle="#000";
  ctx.fillText(i,x+6,y-6);
 });
}

/* ---------- STATE ---------- */
function saveState(){
 undoStack.push(JSON.stringify({points,edges,diagonals,lengths}));
 redoStack=[];
}
function undo(){
 if(undoStack.length){
 redoStack.push(JSON.stringify({points,edges,diagonals,lengths}));
 ({points,edges,diagonals,lengths}=JSON.parse(undoStack.pop()));
 draw();
 }}
function redo(){
 if(redoStack.length){
 undoStack.push(JSON.stringify({points,edges,diagonals,lengths}));
 ({points,edges,diagonals,lengths}=JSON.parse(redoStack.pop()));
 draw();
 }}
function reset(){
 points=[];edges=[];diagonals=[];lengths={};
 shapeClosed=false;addingDiagonal=false;
 canvasLocked=false;
 document.getElementById("output").innerText="Total Area: 0.00 m²";
 resizeCanvas(true);
 draw();
}

/* ---------- EXPORT PDF ---------- */
function exportPDF(){

 const pdf=new jsPDF();

 const tempCanvas=document.createElement("canvas");
 const qualityScale=1.1;

 tempCanvas.width=canvas.width*qualityScale;
 tempCanvas.height=canvas.height*qualityScale;

 const tempCtx=tempCanvas.getContext("2d");

 tempCtx.fillStyle="#FFFFFF";
 tempCtx.fillRect(0,0,tempCanvas.width,tempCanvas.height);

 tempCtx.scale(qualityScale,qualityScale);
 tempCtx.drawImage(canvas,0,0);

 const img=tempCanvas.toDataURL("image/jpeg",0.55);

 const pageWidth=pdf.internal.pageSize.getWidth();
 const pageHeight=pdf.internal.pageSize.getHeight();

 const imgWidth=170;
 const imgHeight=120;

 const xCenter=(pageWidth-imgWidth)/2;

 pdf.setFontSize(14);
 pdf.text("Shape Area Report",10,15);

 pdf.setFontSize(11);
 pdf.text(document.getElementById("output").innerText,10,30);

 pdf.addImage(img,"JPEG",xCenter,55,imgWidth,imgHeight);

 pdf.setFont("helvetica","italic");
 pdf.setFontSize(10);

 const footer="Module Designed By Maddam Venkateswara Rao";
 const textWidth=pdf.getTextWidth(footer);

 pdf.text(footer,(pageWidth-textWidth)/2,pageHeight-10);

 pdf.save("shape_report.pdf");
}
</script>
</body>
</html>
